#!/usr/bin/env python3
"""
Reddit-Markdown CI/CD Runner
============================

A local-first CI/CD system that provides identical functionality
locally and in GitHub Actions. All business logic lives here - GitHub Actions
workflows are just simple orchestrators.

Usage:
    ./ci                 # Run main CI pipeline
    ./ci test           # Run tests only
    ./ci quality        # Run quality checks only
    ./ci security       # Run security scans only
    ./ci release v1.2.3 # Create release
    ./ci deps           # Update dependencies
    ./ci --list         # List available commands
    ./ci --dry-run      # Show what would run without executing
    ./ci --help         # Show detailed help

Examples:
    ./ci                           # Full CI pipeline
    ./ci test --python-only        # Python tests only
    ./ci quality --fix             # Run quality checks and auto-fix
    ./ci release v2.1.0 --draft    # Create draft release
"""

import argparse
import os
import sys
import time
from pathlib import Path
from typing import List, Optional

# Add the project root to Python path
project_root = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(project_root / "python"))

try:
    from ci_runner.runner import CIRunner
    from ci_runner.config import load_config
except ImportError as e:
    print(f"‚ùå Failed to import CI components: {e}")
    print("Make sure you're running this from the project root.")
    sys.exit(1)


def main():
    """Main entry point for the CI system."""
    parser = argparse.ArgumentParser(
        description="Reddit-Markdown CI/CD Runner",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    # Primary commands
    parser.add_argument(
        "command",
        nargs="?",
        default="ci",
        help="Command to run: ci, test, quality, security, deps, release"
    )

    # Global options
    parser.add_argument(
        "--dry-run", "-n",
        action="store_true",
        help="Show what would be executed without running"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Enable verbose output"
    )
    parser.add_argument(
        "--list", "-l",
        action="store_true",
        help="List available commands and exit"
    )
    parser.add_argument(
        "--config", "-c",
        help="Path to config file (default: ci-config.yml)"
    )

    # Test options
    parser.add_argument(
        "--python-only",
        action="store_true",
        help="Run only Python tests"
    )
    parser.add_argument(
        "--test-pattern",
        help="Test file pattern to run"
    )

    # Quality options
    parser.add_argument(
        "--fix",
        action="store_true",
        help="Auto-fix quality issues where possible"
    )

    # Release options
    parser.add_argument(
        "--draft",
        action="store_true",
        help="Create draft release"
    )

    # Parse arguments
    args = parser.parse_args()

    # Load configuration
    try:
        config = load_config(args.config)
    except Exception as e:
        print(f"‚ùå Failed to load configuration: {e}")
        return 1

    # Initialize runner
    runner = CIRunner(config, verbose=args.verbose, dry_run=args.dry_run)

    # Handle list command
    if args.list:
        runner.list_commands()
        return 0

    # Execute command
    command = args.command.lower()
    start_time = time.time()

    try:
        if command == "ci":
            success = runner.run_ci_pipeline(**vars(args))
        elif command == "test":
            success = runner.run_tests(**vars(args))
        elif command == "quality":
            success = runner.run_quality(**vars(args))
        elif command == "security":
            success = runner.run_security(**vars(args))
        elif command == "deps":
            success = runner.run_dependencies(**vars(args))
        elif command == "release":
            if len(sys.argv) < 3:
                print("‚ùå Release command requires a version tag")
                print("Usage: ./ci release v1.2.3")
                return 1
            version = sys.argv[2]
            success = runner.run_release(version, **vars(args))
        else:
            print(f"‚ùå Unknown command: {command}")
            print("Run './ci --list' to see available commands")
            return 1

        duration = time.time() - start_time

        if success:
            runner.log_success(f"‚úÖ Command '{command}' completed successfully in {duration:.1f}s")
            return 0
        else:
            runner.log_error(f"‚ùå Command '{command}' failed after {duration:.1f}s")
            return 1

    except KeyboardInterrupt:
        print("\nüõë Interrupted by user")
        return 130
    except Exception as e:
        runner.log_error(f"üí• Command failed with exception: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())
